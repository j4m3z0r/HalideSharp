
// Ensure that the set of types here matches those listed in magicmacros.h
replace(BufferTypes => (Int, UInt, Float, Short, UShort, SByte, Byte));
replace(BufferAndNativeTypes => (
    (Int, int),
    (UInt, uint),
    (Float, float),
    (Short, short),
    (UShort, ushort),
    (SByte, sbyte),
    (Byte, byte)));

// Execute the given macro with all variations of containing types specified.
define ExecMacroAllTypes($macro) {
    unroll(BufferType in BufferTypes) {
        $macro(BufferType);
    }
}

// Execute the given macro with all permutations of types for 1 argument.
define ExecMacro1D($macro2d) {
    unroll (T1 in (Var, Expr, RDom)) {
        $macro2d(T1);
    }
}

// Execute the given macro with all permutations of types for 2 arguments,
// except (int, int) -- this is reserved to allow directly reading values from
// buffers (or for other types, we define the (int, int) behavior directly so
// that it's clear what's happening.
define ExecMacro2D($macro2d) {
    unroll (T1 in (Var, Expr, RDom, Int)) {
        unroll(T2 in (Var, Expr, RDom, Int)) {
            static if(!(T1 `code==` Int && T2 `code==` Int))
                $macro2d(T1, T2);
        }
    }
}

// Execute the given macro with all permutations of types for 3 arguments,
// except (int, int, int) -- this is reserved to allow directly reading values
// from buffers (or for other types, we define the (int, int) behavior directly
// so that it's clear what's happening.
define ExecMacro3D($macro3d) {
    unroll (T1 in (Var, Expr, RDom, Int)) {
        unroll(T2 in (Var, Expr, RDom, Int)) {
            unroll(T3 in (Var, Expr, RDom, Int)) {
                static if(!(T1 `code==` Int && T2 `code==` Int && T3 `code==` Int))
                    $macro3d(T1, T2, T3);
            }
        }
    }
}

define region($name, { $(..code); }) {
    #rawText("\n");
    #rawText("#region "); #rawText($name);
    $(..code);
    #rawText("#endregion // "); #rawText($name);
    #rawText("\n");
}


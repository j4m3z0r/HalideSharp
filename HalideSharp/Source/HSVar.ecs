#ecs;

using System;
using System.Runtime.InteropServices;
using System.Xml.Schema;

namespace HalideSharp
{
    public partial class HSVar : HSObject
    {
        public const string CppType = "Var";
        
        [DllImport(Constants.LibName)] private static extern IntPtr Var_New_String([MarshalAs(Constants.StringType)] string name);
        
        public HSVar(string name)
        {
            _cppobj = Var_New_String(name);
        }

        internal HSVar(IntPtr cppobj)
        {
            _cppobj = cppobj;
        }
        
        [DllImport(Constants.LibName)] private static extern void Var_Delete(IntPtr obj);
        
        ~HSVar() {
            if (_cppobj != IntPtr.Zero)
            {
                Var_Delete(_cppobj);
            }
        }

        // HACK: returning false from both operator true and operator false should force us to never short-circuit,
        // meaning that && will always invoke operator&, which calls C++'s operator&& in the wrapper. In short, this
        // allows for the common (x && y) style conditionals.
        public static bool operator true(HSVar v)
        {
            return false;
        }

        public static bool operator false(HSVar v)
        {
            return false;
        }
    }
}

#ecs;

includeFile("OperatorMacros.ecs");

using System;
using System.CodeDom;
using System.Runtime.InteropServices;

namespace HalideSharp
{
    public class HSExpr : HSObject
    {
        public const string CppType = "Expr";
        
        internal HSExpr(IntPtr cppobj)
        {
            _cppobj = cppobj;
        }

        [DllImport(Constants.LibName, EntryPoint = "new_expr_int")]
        private static extern IntPtr NewExprInt(int i);
        
        public HSExpr(int i)
        {
            _cppobj = NewExprInt(i);
        }

        [DllImport(Constants.LibName, EntryPoint = "delete_expr")]
        private static extern void DeleteExpr(IntPtr obj);
        
        ~HSExpr()
        {
            if (_cppobj != IntPtr.Zero)
            {
                DeleteExpr(_cppobj);
            }
        }

        
        // <expr> <op> <expr>
        define ExprOperator($OperatorName, $OperatorMethodName) {
            replacePP(CFunction => concatId(Operator_Expr_, $OperatorName, _Expr)) {

                [DllImport(Constants.LibName)] private static extern IntPtr CFunction(IntPtr v1, IntPtr v2);
                public static HSExpr $OperatorMethodName(HSExpr v1, HSExpr v2) {
                    return new HSExpr(CFunction(HSUtil.CArg(v1), HSUtil.CArg(v2)));
                }
            }
        }
        ExecAllOperators(ExprOperator);
        
        // <expr> <op> <var>
        define ExprVarOperator($OperatorName, $OperatorMethodName) {
            replacePP(CFunction => concatId(Operator_Expr_, $OperatorName, _Var)) {

                [DllImport(Constants.LibName)] private static extern IntPtr CFunction(IntPtr v1, IntPtr v2);
                public static HSExpr $OperatorMethodName(HSExpr v1, HSVar v2) {
                    return new HSExpr(CFunction(HSUtil.CArg(v1), HSUtil.CArg(v2)));
                }
            }
        }
        ExecAllOperators(ExprVarOperator);
        
        // <expr> <op> <float> AND <float> <op> <expr>
        define FloatOperator($OperatorName, $OperatorMethodName) {
            replacePP(CFunction => concatId(Operator_Expr_, $OperatorName, _Float)) {

                [DllImport(Constants.LibName)] private static extern IntPtr CFunction(IntPtr v1, float f);
                public static HSExpr $OperatorMethodName(HSExpr v1, float f) {
                    return new HSExpr(CFunction(HSUtil.CArg(v1), HSUtil.CArg(f)));
                }
            }

            replacePP(CFunction => concatId(Operator_Float_, $OperatorName, _Expr)) {

                [DllImport(Constants.LibName)] private static extern IntPtr CFunction(float f, IntPtr v1);
                public static HSExpr $OperatorMethodName(float f, HSExpr v1) {
                    return new HSExpr(CFunction(HSUtil.CArg(f), HSUtil.CArg(v1)));
                }
            }

        }
        ExecAllOperators(FloatOperator);

        // <expr> <op> <int> AND <int> <op> <expr>
        define IntOperator($OperatorName, $OperatorMethodName) {
            replacePP(CFunction => concatId(Operator_Expr_, $OperatorName, _Int)) {

                [DllImport(Constants.LibName)] private static extern IntPtr CFunction(IntPtr v1, int i);
                public static HSExpr $OperatorMethodName(HSExpr v1, int i) {
                    return new HSExpr(CFunction(HSUtil.CArg(v1), HSUtil.CArg(i)));
                }
            }
            
            replacePP(CFunction => concatId(Operator_Int_, $OperatorName, _Expr)) {

                [DllImport(Constants.LibName)] private static extern IntPtr CFunction(int i, IntPtr v1);
                public static HSExpr $OperatorMethodName(int i, HSExpr v1) {
                    return new HSExpr(CFunction(HSUtil.CArg(i), HSUtil.CArg(v1)));
                }
            }
        }
        ExecAllOperators(IntOperator);

        [DllImport(Constants.LibName, EntryPoint = "expr_to_string")]
        private static extern IntPtr ExprToString(IntPtr exp);

        [DllImport(Constants.LibC, EntryPoint = "free")]
        private static extern void Free(IntPtr p);
        
        public override string ToString()
        {
            var stringPtr = ExprToString(_cppobj);
            var result = Marshal.PtrToStringAnsi(stringPtr);
            Free(stringPtr);

            return result;
        }

        // HACK: returning false from both operator true and operator false should force us to never short-circuit,
        // meaning that && will always invoke operator&, which calls C++'s operator&& in the wrapper. In short, this
        // allows for the common (x && y) style conditionals.
        public static bool operator true(HSExpr e)
        {
            return false;
        }

        public static bool operator false(HSExpr e)
        {
            return false;
        }

    }
}

#ecs;

includeFile("MagicMacros.ecs");

using System;
using System.Runtime.InteropServices;

// Execute the given macro with all variations of containing types specified.
define ExecMacroAllTypes($macro) {
    unroll(BufferType in BufferTypes) {
        $macro(BufferType);
    }
}

// Execute the given macro with all permutations of types for 3 arguments, plus all types for the
// container object (eg: Buffer<float>, Buffer<byte>, etc).
define ExecMacroAllTypes2D($macro2d) {
    define TypedEval($T1, $T2) {
        unroll (BufferType in BufferTypes) {
            $macro2d(BufferType, $T1, $T2);
        }
    }
    ExecMacro2D(TypedEval);
}

// Execute the given macro with all permutations of types for 3 arguments, plus all types for the
// container object (eg: Buffer<float>, Buffer<byte>, etc).
define ExecMacroAllTypes3D($macro3d)
{
    define TypedEval($T1, $T2, $T3)
    {
        unroll (BufferType in BufferTypes)
        {
            $macro3d(BufferType, $T1, $T2, $T3);
        }
    }
    ExecMacro3D(TypedEval);
}

namespace HalideSharp
{
    internal class CppBuffer
    {

        //region 2D constructors
        unroll (BufferType in BufferTypes) {
            replacePP(MethodName => concatId(BufferOf, BufferType, _New_IntInt)) {
                [DllImport(Constants.LibName)] public static extern IntPtr MethodName(int width, int height);
            }
        }
        //endregion


        //region 3D constructors
        unroll (BufferType in BufferTypes) {
            replacePP(MethodName => concatId(BufferOf, BufferType, _New_IntIntInt)) {
                [DllImport(Constants.LibName)] public static extern IntPtr MethodName(int width, int height, int channels);
            }
        }
        //endregion

        //region destructors
        unroll(BufferType in BufferTypes) {
            replacePP(MethodName => concatId(BufferOf, BufferType, _Delete)) {
                [DllImport(Constants.LibName)] public static extern void MethodName(IntPtr obj);
            }
        }
        //endregion

        //region 2D indexers
        //region int indexers
        unroll(BufferType in BufferTypes) {
            replacePP(MethodName => concatId(BufferOf, BufferType, _GetVal_IntInt)) {
                [DllImport(Constants.LibName)] public static extern void MethodName(IntPtr obj, int x, int y, IntPtr result);
            }
        }
        //endregion

        // 2D indexer entry points
        define Indexer2D($BufferType, $T1, $T2) {
            replace(MethodName => concatId(BufferOf, $BufferType, _GetExpr_, $T1, $T2)) {
                [DllImport(Constants.LibName)] public static extern IntPtr MethodName(IntPtr obj, IntPtr x, IntPtr y);
            }

        }
        ExecMacroAllTypes2D(Indexer2D);

        //endregion
        
        //region 3D indexers

        //region int indexers
        unroll(BufferType in BufferTypes) {
            replacePP(MethodName => concatId(BufferOf, BufferType, _GetVal_IntIntInt)) {
                [DllImport(Constants.LibName)] public static extern void MethodName(IntPtr obj, int x, int y, int z, IntPtr result);
            }
        }
        //endregion

        // 3D indexer entry points
        define Indexer3D($BufferType, $T1, $T2, $T3)
        {
            replace(MethodName => concatId(BufferOf, $BufferType, _GetExpr_, $T1, $T2, $T3)) {
                [DllImport(Constants.LibName)] public static extern IntPtr MethodName(IntPtr obj, IntPtr x, IntPtr y, IntPtr z);
            }

        }

        ExecMacroAllTypes3D(Indexer3D);
        //endregion
        
        define SetMin($BufferType) {
            replace(MethodName => concatId(BufferOf, $BufferType, _SetMin, _IntInt)) {
                [DllImport(Constants.LibName)] public static extern int MethodName(IntPtr obj, int x, int y);
            }
        }
        ExecMacroAllTypes(SetMin);

        //region Dimension size accessors
        define Accessors($BufferType) {
            unroll((DIMENSION) in (Width, Height, Channels)) {
                replace(MethodName => concatId(BufferOf, $BufferType, _, DIMENSION)) {
                    [DllImport(Constants.LibName)] public static extern int MethodName(IntPtr obj);
                }
            }
        }
        ExecMacroAllTypes(Accessors);
        //endregion

        
        [DllImport(Constants.LibName)] public static extern IntPtr BufferOfByte_LoadImage_String([MarshalAs(Constants.StringType)] string filename);
        
        [DllImport(Constants.LibName)] public static extern IntPtr BufferOfByte_SaveImage_String(IntPtr buffer, [MarshalAs(Constants.StringType)] string filename);

        define CopyToHost($BufferType) {
            replace(MethodName => concatId(BufferOf, $BufferType, _CopyToHost)) {
                [DllImport(Constants.LibName)] public static extern void MethodName(IntPtr self);
            }
        }
        ExecMacroAllTypes(CopyToHost);
    }
    
    public class HSBuffer<T> : HSObject
        where T: struct
    {
        private void CheckType()
        {
            if (typeof(T) != typeof(int) && typeof(T) != typeof(float) && typeof(T) != typeof(byte))
            {
                throw new NotImplementedException($"Buffer type {typeof(T)} unsupported");
            }
        }
        
        public HSBuffer(int width, int height)
        {
            unroll((BufferType, NativeType) in BufferAndNativeTypes) {
                replacePP(MethodName => concatId(BufferOf, BufferType, _New_IntInt)) {
                    if(typeof(T) == typeof(NativeType)) { _cppobj = CppBuffer.MethodName(width, height); return; }
                }
            }
            throw new NotImplementedException($"Buffer type {typeof(T)} unsupported");
        }
        
        public HSBuffer(int width, int height, int channels)
        {
            unroll((BufferType, NativeType) in BufferAndNativeTypes) {
                replacePP(MethodName => concatId(BufferOf, BufferType, _New_IntIntInt)) {
                    if(typeof(T) == typeof(NativeType)) { _cppobj = CppBuffer.MethodName(width, height, channels); return; }
                }
            }
            throw new NotImplementedException($"Buffer type {typeof(T)} unsupported");
        }
        
        internal HSBuffer(IntPtr cppobj)
        {
            CheckType();
            _cppobj = cppobj;
        }

        public static HSBuffer<T> LoadImage(string filename)
        {
            if (typeof(T) == typeof(byte))
            {
                return new HSBuffer<T>(CppBuffer.BufferOfByte_LoadImage_String(filename));
            }
            else
            {
                throw new NotImplementedException($"Can't load images to buffer of type {typeof(T)}");
            }
        }

        public void SaveImage(string filename)
        {
            if (typeof(T) == typeof(byte))
            {
                CppBuffer.BufferOfByte_SaveImage_String(HSUtil.CArg(this), HSUtil.CArg(filename));
            }
            else
            {
                throw new NotImplementedException($"Can't save images to buffer of type {typeof(T)}");
            }
        }

        ~HSBuffer()
        {
            CheckType();
            if (_cppobj == IntPtr.Zero)
            {
                return;
            }
            unroll((BufferType, NativeType) in BufferAndNativeTypes) {
                replacePP(MethodName => concatId(BufferOf, BufferType, _Delete)) {
                    if(typeof(T) == (typeof(NativeType))) { CppBuffer.MethodName(_cppobj); return; }
                }
            }
            throw new NotImplementedException($"No destructor for type {typeof(T)}");
        }

        public T GetVal(int x, int y)
        {
            // Here's what's going on with this piece of pure artisinal C#: over in C++ land, Halide::Buffer is a
            // templated type. However, since we need to route calls to that templated C++ code via a C interface,
            // we have a different version of the C wrapper function for each type we're interested in -- hence the
            // test against typeof(T). However, the real trick is in fooling C# into letting C/C++ fill in the
            // result value. We can't use unsafe & fixed, since T is a generic, and you can't have a generic type
            // for fixed(). GCHandle will do the trick, but there's one final wrinkle: if you use GCHandle on a
            // non-object type (which we have constrained T to be), it won't pass the address of the original value
            // but will instead make a copy of the value and give you the address of that copy. At that point, C++
            // will fill in the correct value, and C# will promptly throw it away. To workaround this, we create
            // a temporary array of Ts of length 1, take the address of the array, then return the first element.
            var result = new T[1];
            var resultHandle = GCHandle.Alloc(result, GCHandleType.Pinned);

            try
            {
                unroll((BufferType, NativeType) in BufferAndNativeTypes)
                {
                    replacePP(MethodName => concatId(BufferOf, BufferType, _GetVal_IntInt)) {
                        if(typeof(T) == typeof(NativeType)) { CppBuffer.MethodName(HSUtil.CArg(this), HSUtil.CArg(x), HSUtil.CArg(y), HSUtil.CArg(resultHandle)); return result[0]; }
                    }
                }
                throw new NotImplementedException($"Buffer type {typeof(T)} unsupported");
            }
            finally
            {
                resultHandle.Free();
            }
        }

        public T GetVal(int x, int y, int z)
        {
            // See above
            var result = new T[1];
            var resultHandle = GCHandle.Alloc(result, GCHandleType.Pinned);

            try
            {
                unroll((BufferType, NativeType) in BufferAndNativeTypes)
                {
                    replacePP(MethodName => concatId(BufferOf, BufferType, _GetVal_IntIntInt)) {
                        if(typeof(T) == typeof(NativeType)) { CppBuffer.MethodName(HSUtil.CArg(this), HSUtil.CArg(x), HSUtil.CArg(y), HSUtil.CArg(z), HSUtil.CArg(resultHandle)); return result[0]; }
                    }
                }
                throw new NotImplementedException($"Buffer type {typeof(T)} unsupported");
            }
            finally
            {
                resultHandle.Free();
            }
        }

        public T this[int x, int y] => GetVal(x, y);
        public T this[int x, int y, int z] => GetVal(x, y, z);

        //region 2D indexers
        define Indexer2D($T1, $T2) {
            replacePP(arg1 => concatId(HS, $T1)) {
                replacePP(arg2 => concatId(HS, $T2)) {
                    public HSExpr GetExpr(arg1 x, arg2 y)
                    {
                        unroll((BufferType, NativeType) in BufferAndNativeTypes)
                        {
                            replacePP(MethodName => concatId(BufferOf, BufferType, _GetExpr_, $T1, $T2)) {
                                if(typeof(T) == typeof(NativeType)) { return new HSExpr(CppBuffer.MethodName(HSUtil.CArg(this), HSUtil.CArg(x), HSUtil.CArg(y))); }
                            }

                        }
                        throw new NotImplementedException("Buffer type {typeof(T)} unsupported");
                    }
                    public HSExpr this[arg1 x, arg2 y] => GetExpr(x, y);
                }
            }
        }
        ExecMacro2D(Indexer2D);
        //endregion

        //region 3D indexers
        define Indexer3D($T1, $T2, $T3) {
            replacePP(arg1 => concatId(HS, $T1)) {
                replacePP(arg2 => concatId(HS, $T2)) {
                    replacePP(arg3 => concatId(HS, $T3)) {
                        public HSExpr GetExpr(arg1 x, arg2 y, arg3 z)
                        {
                            unroll((BufferType, NativeType) in BufferAndNativeTypes)
                            {
                                replacePP(MethodName => concatId(BufferOf, BufferType, _GetExpr_, $T1, $T2, $T3)) {
                                    if(typeof(T) == typeof(NativeType)) { return new HSExpr(CppBuffer.MethodName(HSUtil.CArg(this), HSUtil.CArg(x), HSUtil.CArg(y), HSUtil.CArg(z))); }
                                }
                            }
                            throw new NotImplementedException("Buffer type {typeof(T)} unsupported");
                        }
                        public HSExpr this[arg1 x, arg2 y, arg3 z] => GetExpr(x, y, z);
                    }
                }
            }
        }
        ExecMacro3D(Indexer3D);
        //endregion
        
        public void SetMin(int x, int y)
        {
            unroll((BufferType, NativeType) in BufferAndNativeTypes)
            {
                replacePP(MethodName => concatId(BufferOf, BufferType, _, SetMin, _IntInt)) {
                    if(typeof(T) == typeof(NativeType)) { CppBuffer.MethodName(HSUtil.CArg(this), HSUtil.CArg(x), HSUtil.CArg(y)); return; }
                }
            }
            throw new NotImplementedException($"Buffer type {typeof(T)} unsupported");
        }

        //region simple int accessors
        unroll (FieldName in (Width, Height, Channels)) {
            public int FieldName
            {
                get
                {
                    unroll ((BufferType, NativeType) in BufferAndNativeTypes) {
                        replacePP(MethodName => concatId(BufferOf, BufferType, _, FieldName)) {
                            if(typeof(T) == typeof(NativeType)) { return CppBuffer.MethodName(HSUtil.CArg(this)); }
                        }
                    }
                    throw new NotImplementedException($"Buffer type {typeof(T)} unsupported");
                }
            }
        }
        //endregion

        public void CopyToHost()
        {
            unroll((BufferType, NativeType) in BufferAndNativeTypes)
            {
                replacePP(MethodName => concatId(BufferOf, BufferType, _CopyToHost)) {
                    if(typeof(T) == typeof(NativeType)) { CppBuffer.MethodName(HSUtil.CArg(this)); return; }
                }
            }
            throw new NotImplementedException($"Buffer type {typeof(T)} unsupported");
        }
    }
}
